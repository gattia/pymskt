# dependencies/pymskt/testing/image/test_meniscus_processing.py
import os
import pytest
import numpy as np
import SimpleITK as sitk
import warnings

# Adjust path based on actual location relative to pymskt root if needed
# Assuming tests run from pymskt root or similar context where 'data' is accessible
DATA_DIR = os.path.join(os.path.dirname(__file__), "..", "..", "data")
SEG_FILENAME = "SAG_3D_DESS_RIGHT_bones_cart_men_fib-label.nrrd"
SEG_FILEPATH = os.path.join(DATA_DIR, SEG_FILENAME)

# Check if data file exists, skip tests if not
if not os.path.exists(SEG_FILEPATH):
     pytest.skip(f"Test data file not found at {SEG_FILEPATH}", allow_module_level=True)

from pymskt.image.meniscus_processing import verify_and_correct_meniscus_sides

# --- Labels (Confirm these match the NRRD file) ---
MED_MEN_LBL = 10
LAT_MEN_LBL = 9
MED_TIB_CART_LBL = 2
LAT_TIB_CART_LBL = 3
TIB_LBL = 6 # Based on user modifications to meniscus_processing.py default
ML_AXIS = 0

@pytest.fixture(scope="module")
def segmentation_data():
    """Loads the segmentation image and extracts array."""
    try:
        img = sitk.ReadImage(SEG_FILEPATH)
        arr = sitk.GetArrayFromImage(img)
        # Check if all required labels are present
        present_labels = np.unique(arr)
        required = {MED_MEN_LBL, LAT_MEN_LBL, MED_TIB_CART_LBL, LAT_TIB_CART_LBL, TIB_LBL}
        if not required.issubset(present_labels):
            pytest.skip(f"Test data missing one or more required labels ({required - set(present_labels)})", allow_module_level=True)
        return img, arr
    except Exception as e:
        pytest.fail(f"Failed to load or process test data {SEG_FILEPATH}: {e}")

def _check_masks(seg_array, med_mask, lat_mask, med_lbl, lat_lbl):
    """Helper function for common mask assertions."""
    assert isinstance(med_mask, np.ndarray) and med_mask.dtype == bool
    assert isinstance(lat_mask, np.ndarray) and lat_mask.dtype == bool
    assert med_mask.shape == seg_array.shape
    assert lat_mask.shape == seg_array.shape

    # Check for overlap
    assert np.sum(med_mask & lat_mask) == 0, "Overlap found between cleaned medial and lateral masks."

    # Check for completeness
    original_meniscus_mask = (seg_array == med_lbl) | (seg_array == lat_lbl)
    cleaned_union_mask = med_mask | lat_mask
    assert np.all(cleaned_union_mask == original_meniscus_mask), "Union of cleaned masks does not match original meniscus mask."

def _check_plane_split(mask, center_split, axis, side_is_positive):
     """Helper to check if mask voxels are on the correct side of a plane."""
     if mask.sum() == 0: # Skip check if mask is empty
         return
     coords = np.array(np.where(mask))
     axis_coords = coords[axis, :]
     if side_is_positive:
         assert np.all(axis_coords >= center_split), f"Some voxels in mask are unexpectedly below split {center_split} on axis {axis}"
     else:
         assert np.all(axis_coords < center_split), f"Some voxels in mask are unexpectedly at or above split {center_split} on axis {axis}"

# --- Helper function to get original masks ---
def get_original_masks(seg_array):
    original_med_mask = seg_array == MED_MEN_LBL
    original_lat_mask = seg_array == LAT_MEN_LBL
    return original_med_mask, original_lat_mask

# --- Test Cases ---

def test_verify_meniscus_tibial_centroid(segmentation_data):
    """Test the 'tibial_centroid' method."""
    img, arr = segmentation_data
    med_mask, lat_mask, center_split = verify_and_correct_meniscus_sides(
        seg_array=arr,
        med_meniscus_label=MED_MEN_LBL,
        lat_meniscus_label=LAT_MEN_LBL,
        med_tib_cart_label=MED_TIB_CART_LBL,
        lat_tib_cart_label=LAT_TIB_CART_LBL,
        tib_label=TIB_LBL,
        ml_axis=ML_AXIS,
        method='tibial_centroid',
        verbose=True # Enable verbose for potential debugging
    )
    _check_masks(arr, med_mask, lat_mask, MED_MEN_LBL, LAT_MEN_LBL)
    assert center_split is not None

    # Determine expected medial side based on cartilage relative to split
    med_cart_locs = np.where(arr == MED_TIB_CART_LBL)
    middle_med_cart = med_cart_locs[ML_AXIS].mean()
    med_side_is_positive = np.sign(middle_med_cart - center_split) > 0

    _check_plane_split(med_mask, center_split, ML_AXIS, med_side_is_positive)
    _check_plane_split(lat_mask, center_split, ML_AXIS, not med_side_is_positive)

def test_verify_meniscus_cartilage_midpoint(segmentation_data):
    """Test the 'cartilage_midpoint' method."""
    img, arr = segmentation_data
    med_mask, lat_mask, center_split = verify_and_correct_meniscus_sides(
        seg_array=arr,
        med_meniscus_label=MED_MEN_LBL,
        lat_meniscus_label=LAT_MEN_LBL,
        med_tib_cart_label=MED_TIB_CART_LBL,
        lat_tib_cart_label=LAT_TIB_CART_LBL,
        tib_label=TIB_LBL,
        ml_axis=ML_AXIS,
        method='cartilage_midpoint',
        verbose=True
    )
    _check_masks(arr, med_mask, lat_mask, MED_MEN_LBL, LAT_MEN_LBL)
    assert center_split is not None

    # Determine expected medial side based on cartilage relative to split
    med_cart_locs = np.where(arr == MED_TIB_CART_LBL)
    middle_med_cart = med_cart_locs[ML_AXIS].mean()
    med_side_is_positive = np.sign(middle_med_cart - center_split) > 0

    _check_plane_split(med_mask, center_split, ML_AXIS, med_side_is_positive)
    _check_plane_split(lat_mask, center_split, ML_AXIS, not med_side_is_positive)

def test_verify_meniscus_cartilage_distance(segmentation_data):
    """Test the 'cartilage_distance' method."""
    img, arr = segmentation_data
    pixel_spacing = img.GetSpacing()
    spacing_zyx = (pixel_spacing[2], pixel_spacing[1], pixel_spacing[0])
    # Assuming isotropic voxels for this test, pass default spacing
    med_mask, lat_mask, center_split = verify_and_correct_meniscus_sides(
        seg_array=arr,
        med_meniscus_label=MED_MEN_LBL,
        lat_meniscus_label=LAT_MEN_LBL,
        med_tib_cart_label=MED_TIB_CART_LBL,
        lat_tib_cart_label=LAT_TIB_CART_LBL,
        tib_label=TIB_LBL,
        ml_axis=ML_AXIS,
        method='cartilage_distance',
        spacing_zyx=spacing_zyx,
        verbose=True
    )
    _check_masks(arr, med_mask, lat_mask, MED_MEN_LBL, LAT_MEN_LBL)
    assert center_split is None # Distance method doesn't return a split plane coord

    # Add more specific checks? Difficult without ground truth split.
    # Check if total number of medial/lateral voxels is reasonable?
    assert med_mask.sum() > 0
    assert lat_mask.sum() > 0

@pytest.mark.skip("Logistic meniscus method is not implemented yet.")
def test_verify_meniscus_logistic(segmentation_data):
    """Test the 'logistic_meniscus' method."""
    # img, arr = segmentation_data
    # # Expect NotImplementedError
    # with pytest.raises(NotImplementedError):
    #     verify_and_correct_meniscus_sides(
    #         seg_array=arr,
    #         med_meniscus_label=MED_MEN_LBL,
    #         lat_meniscus_label=LAT_MEN_LBL,
    #         med_tib_cart_label=MED_TIB_CART_LBL, # Still needed for direction check/warning
    #         lat_tib_cart_label=LAT_TIB_CART_LBL,
    #         tib_label=TIB_LBL,
    #         ml_axis=ML_AXIS,
    #         method='logistic_meniscus',
    #         verbose=True
    #     )

    # --- Code below is unreachable due to NotImplementedError, kept for future reference ---
    # _check_masks(arr, med_mask, lat_mask, MED_MEN_LBL, LAT_MEN_LBL)
    # assert center_split is not None
    #
    # # Determine expected medial side based on logistic coefficient
    # # (Re-run slightly redundant logic here to get theta for assertion)
    # from pymskt.image.meniscus_processing import _logistic, _cost_function, _gradient, _SCIPY_AVAILABLE
    # if not _SCIPY_AVAILABLE: pytest.skip("scipy not available for logistic regression test")
    # from scipy.optimize import minimize
    # original_meniscus_mask = (arr == MED_MEN_LBL) | (arr == LAT_MEN_LBL)
    # meniscus_coords = np.array(np.where(original_meniscus_mask)).T
    # meniscus_ml_coords = meniscus_coords[:, ML_AXIS]
    # original_med_mask_bool = arr[original_meniscus_mask] == MED_MEN_LBL
    # meniscus_labels_binary = np.where(original_med_mask_bool, 0, 1)
    # X = np.vstack([np.ones(len(meniscus_ml_coords)), meniscus_ml_coords]).T
    # theta = np.zeros(X.shape[1])
    # result = minimize(_cost_function, theta, args=(X, meniscus_labels_binary),
    #                   method='BFGS', jac=_gradient, options={'maxiter': 400})
    # assert result.success # Ensure convergence for assertion check
    # theta_optimized = result.x
    # med_side_is_positive = theta_optimized[1] < 0 # Medial corresponds to label 0
    #
    # _check_plane_split(med_mask, center_split, ML_AXIS, med_side_is_positive)
    # _check_plane_split(lat_mask, center_split, ML_AXIS, not med_side_is_positive)

def test_verify_meniscus_split_combined_tibial_centroid(segmentation_data):
    """Test splitting a combined meniscus label using 'tibial_centroid'."""
    img, arr_ = segmentation_data
    arr = arr_.copy()
    original_med_mask, original_lat_mask = get_original_masks(arr)

    # Combine lateral into medial label
    COMBINED_LBL = MED_MEN_LBL # Use medial label for the combined mask
    arr[arr == LAT_MEN_LBL] = COMBINED_LBL

    # Verify that the original lateral label is gone
    assert np.sum(arr == LAT_MEN_LBL) == 0
    # Verify that the combined label exists
    assert np.sum(arr == COMBINED_LBL) == np.sum(original_med_mask | original_lat_mask)

    pixel_spacing = img.GetSpacing()
    spacing_zyx = (pixel_spacing[2], pixel_spacing[1], pixel_spacing[0])
    # Run correction using cartilage distance (should be robust to initial label)
    med_mask, lat_mask, _ = verify_and_correct_meniscus_sides(
        seg_array=arr,
        med_meniscus_label=COMBINED_LBL, # Pass the combined label as 'medial'
        lat_meniscus_label=LAT_MEN_LBL,   # Pass original lateral (won't be found initially)
        med_tib_cart_label=MED_TIB_CART_LBL,
        lat_tib_cart_label=LAT_TIB_CART_LBL,
        tib_label=TIB_LBL,
        ml_axis=ML_AXIS,
        method='tibial_centroid', # Distance should work well here
        spacing_zyx=spacing_zyx,
        verbose=True
    )

    # Check basic mask properties
    _check_masks(arr, med_mask, lat_mask, COMBINED_LBL, LAT_MEN_LBL) # Pass combined label

    # Assert that the split matches the original segmentation masks
    assert np.all(med_mask == original_med_mask), "Split medial mask differs from original"
    assert np.all(lat_mask == original_lat_mask), "Split lateral mask differs from original"


def test_verify_meniscus_split_combined(segmentation_data):
    """Test splitting a combined meniscus label using 'cartilage_distance'."""
    img, arr_ = segmentation_data
    arr = arr_.copy()
    original_med_mask, original_lat_mask = get_original_masks(arr)
    pixel_spacing = img.GetSpacing()
    spacing_zyx = (pixel_spacing[2], pixel_spacing[1], pixel_spacing[0])

    # Combine lateral into medial label
    COMBINED_LBL = MED_MEN_LBL # Use medial label for the combined mask
    arr[arr == LAT_MEN_LBL] = COMBINED_LBL

    # Verify that the original lateral label is gone
    assert np.sum(arr == LAT_MEN_LBL) == 0
    # Verify that the combined label exists
    assert np.sum(arr == COMBINED_LBL) == np.sum(original_med_mask | original_lat_mask)

    # Run correction using cartilage distance (should be robust to initial label)
    med_mask, lat_mask, _ = verify_and_correct_meniscus_sides(
        seg_array=arr,
        med_meniscus_label=COMBINED_LBL, # Pass the combined label as 'medial'
        lat_meniscus_label=LAT_MEN_LBL,   # Pass original lateral (won't be found initially)
        med_tib_cart_label=MED_TIB_CART_LBL,
        lat_tib_cart_label=LAT_TIB_CART_LBL,
        tib_label=TIB_LBL,
        ml_axis=ML_AXIS,
        method='cartilage_distance', # Distance should work well here
        spacing_zyx=spacing_zyx,
        verbose=True
    )

    # Check basic mask properties
    _check_masks(arr, med_mask, lat_mask, COMBINED_LBL, LAT_MEN_LBL) # Pass combined label

    # Assert that the split matches the original segmentation masks
    assert np.all(med_mask == original_med_mask), "Split medial mask differs from original"
    assert np.all(lat_mask == original_lat_mask), "Split lateral mask differs from original"

def test_verify_meniscus_correct_mislabels(segmentation_data):
    """Test correction of mislabeled voxels near the boundary using various methods."""
    img, arr_ = segmentation_data
    arr = arr_.copy()
    original_med_mask, original_lat_mask = get_original_masks(arr)
    arr_corrupted = arr.copy()
    pixel_spacing = img.GetSpacing()
    spacing_zyx = (pixel_spacing[2], pixel_spacing[1], pixel_spacing[0])

    # --- Corrupt data near the tibial centroid boundary ---
    tib_locs = np.where(arr == TIB_LBL)
    middle_tib_bone = tib_locs[ML_AXIS].mean()
    center_split = int(np.round(middle_tib_bone))
    N_CORRUPT = 100 # Number of voxels to mislabel on each side

    # Get indices of original meniscus voxels
    med_indices = np.array(np.where(original_med_mask)).T
    lat_indices = np.array(np.where(original_lat_mask)).T

    if med_indices.shape[0] > N_CORRUPT and lat_indices.shape[0] > N_CORRUPT:
        # Find medial voxels near the boundary (e.g., within 5 voxels laterally)
        med_ml_coords = med_indices[:, ML_AXIS]
        med_near_boundary_idx = np.where((med_ml_coords < center_split) & (med_ml_coords >= center_split - 5))[0]
        # Ensure we don't try to select more than available
        n_med_corrupt = min(N_CORRUPT, len(med_near_boundary_idx))
        if n_med_corrupt > 0:
            med_to_corrupt_indices = np.random.choice(med_near_boundary_idx, n_med_corrupt, replace=False)
            med_coords_to_corrupt = tuple(med_indices[med_to_corrupt_indices].T)
            arr_corrupted[med_coords_to_corrupt] = LAT_MEN_LBL # Mislabel as lateral
            print(f"Mislabeled {n_med_corrupt} medial voxels as lateral.")

        # Find lateral voxels near the boundary (e.g., within 5 voxels medially)
        lat_ml_coords = lat_indices[:, ML_AXIS]
        lat_near_boundary_idx = np.where((lat_ml_coords >= center_split) & (lat_ml_coords < center_split + 5))[0]
         # Ensure we don't try to select more than available
        n_lat_corrupt = min(N_CORRUPT, len(lat_near_boundary_idx))
        if n_lat_corrupt > 0:
            lat_to_corrupt_indices = np.random.choice(lat_near_boundary_idx, n_lat_corrupt, replace=False)
            lat_coords_to_corrupt = tuple(lat_indices[lat_to_corrupt_indices].T)
            arr_corrupted[lat_coords_to_corrupt] = MED_MEN_LBL # Mislabel as medial
            print(f"Mislabeled {n_lat_corrupt} lateral voxels as medial.")

        # --- Test correction with different methods ---
        methods_to_test = ['tibial_centroid', 'cartilage_midpoint', 'cartilage_distance']
        for method in methods_to_test:
            print(f"\nTesting correction with method: {method}")
            try:
                med_mask_fixed, lat_mask_fixed, _ = verify_and_correct_meniscus_sides(
                    seg_array=arr_corrupted,
                    med_meniscus_label=MED_MEN_LBL,
                    lat_meniscus_label=LAT_MEN_LBL,
                    med_tib_cart_label=MED_TIB_CART_LBL,
                    lat_tib_cart_label=LAT_TIB_CART_LBL,
                    tib_label=TIB_LBL,
                    ml_axis=ML_AXIS,
                    method=method,
                    spacing_zyx=spacing_zyx,
                    verbose=True
                )

                # Check basic mask properties against the corrupted array state
                _check_masks(arr_corrupted, med_mask_fixed, lat_mask_fixed, MED_MEN_LBL, LAT_MEN_LBL)

                # Assert that the *fixed* masks match the *original* correct masks
                assert np.all(med_mask_fixed == original_med_mask), f"Corrected medial mask differs from original using method {method}"
                assert np.all(lat_mask_fixed == original_lat_mask), f"Corrected lateral mask differs from original using method {method}"
                print(f"Method {method} successfully corrected mislabels.")

            except ValueError as e:
                 pytest.fail(f"Method {method} raised unexpected ValueError during correction test: {e}")
            except NotImplementedError:
                 pytest.skip(f"Method {method} is not implemented.")

    else:
        pytest.skip("Not enough meniscus voxels near boundary to perform mislabeling test.")

def test_verify_meniscus_sitk_wrapper_cartilage_distance(segmentation_data):
    """Test the sitk wrapper function with the 'cartilage_distance' method."""
    img, arr = segmentation_data # Get both image and array for comparison

    # --- Call the SITK wrapper ---
    # We need to import the wrapper function specifically
    from pymskt.image.meniscus_processing import verify_and_correct_meniscus_sides_sitk

    med_mask_sitk, lat_mask_sitk, center_split_sitk = verify_and_correct_meniscus_sides_sitk(
        seg_image=img, # Pass the sitk.Image directly
        med_meniscus_label=MED_MEN_LBL,
        lat_meniscus_label=LAT_MEN_LBL,
        med_tib_cart_label=MED_TIB_CART_LBL,
        lat_tib_cart_label=LAT_TIB_CART_LBL,
        tib_label=TIB_LBL,
        ml_axis=ML_AXIS,
        method='cartilage_distance',
        verbose=True
    )

    # --- Perform basic checks on the wrapper output ---
    _check_masks(arr, med_mask_sitk, lat_mask_sitk, MED_MEN_LBL, LAT_MEN_LBL)
    assert center_split_sitk is None # Distance method doesn't return a split plane coord
    assert med_mask_sitk.sum() > 0
    assert lat_mask_sitk.sum() > 0

    # --- Optional: Compare with direct call to original function for consistency ---
    # Extract spacing manually for the original function call
    pixel_spacing = img.GetSpacing()
    spacing_zyx = tuple(reversed(pixel_spacing))

    med_mask_orig, lat_mask_orig, center_split_orig = verify_and_correct_meniscus_sides(
        seg_array=arr,
        med_meniscus_label=MED_MEN_LBL,
        lat_meniscus_label=LAT_MEN_LBL,
        med_tib_cart_label=MED_TIB_CART_LBL,
        lat_tib_cart_label=LAT_TIB_CART_LBL,
        tib_label=TIB_LBL,
        ml_axis=ML_AXIS,
        method='cartilage_distance',
        spacing_zyx=spacing_zyx, # Pass spacing explicitly
        verbose=False # No need for verbose output again
    )

    # Assert that the results from the wrapper match the original function
    assert np.all(med_mask_sitk == med_mask_orig)
    assert np.all(lat_mask_sitk == lat_mask_orig)
    assert center_split_sitk == center_split_orig

# --- Test Error Conditions ---

def test_verify_meniscus_missing_cartilage_errors(segmentation_data):
    """Test errors when cartilage is required but missing."""
    img, arr_ = segmentation_data
    arr = arr_.copy()
    # Remove tibial cartilage labels
    arr[arr == MED_TIB_CART_LBL] = 0
    arr[arr == LAT_TIB_CART_LBL] = 0

    with pytest.raises(ValueError, match="requires valid medial and lateral"):
        verify_and_correct_meniscus_sides(arr, method='cartilage_midpoint', med_tib_cart_label=MED_TIB_CART_LBL, lat_tib_cart_label=LAT_TIB_CART_LBL)
    with pytest.raises(ValueError, match="requires valid medial and lateral"):
        verify_and_correct_meniscus_sides(arr, method='cartilage_distance', med_tib_cart_label=MED_TIB_CART_LBL, lat_tib_cart_label=LAT_TIB_CART_LBL)

def test_verify_meniscus_contradictory_cartilage_error(segmentation_data):
    """Test error when cartilage centroids are on the same side for 'cartilage_midpoint'."""
    img, arr_ = segmentation_data
    arr = arr_.copy()
    # Artificially move all lateral cartilage to the medial side (example modification)
    # This requires knowing the split point roughly first
    tib_locs = np.where(arr == TIB_LBL)
    middle_tib_bone = tib_locs[ML_AXIS].mean()
    center_split = int(np.round(middle_tib_bone))

    # Find lateral cartilage and shift its ML coordinate (crude example)
    lat_cart_indices = np.where(arr == LAT_TIB_CART_LBL)
    if lat_cart_indices[0].size > 0:
        # Shift lateral cartilage ML coords to be > center_split
        # This is complex to do correctly without modifying many voxels.
        # Instead, let's test the ValueError directly raised inside the function
        # We know from test_verify_meniscus_tibial_centroid they are on opposite sides.
        # For 'cartilage_midpoint' the specific error about same side is raised.
        with pytest.raises(ValueError, match="same side"):
             # Temporarily mock the centroid calculation result? Hard to do cleanly.
             # Let's assume the internal check works and skip modifying data for now.
             # If we had a test case known to have this issue, we'd use it.
             pytest.skip("Skipping contradictory cartilage test - hard to create artificial data easily.")

# Add more tests? e.g., different axes, different label numbers, anisotropic spacing? 